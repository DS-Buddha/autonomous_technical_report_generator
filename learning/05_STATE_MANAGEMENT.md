# State Management: The Backbone of Multi-Agent Systems

## ðŸŽ¯ Why State Management Matters

### The Problem

**Without proper state management:**
```python
# Chaos: Agents can't communicate
researcher_output = researcher.run("RAG")
coder_output = coder.run("???")  # How does coder know what researcher found?

# Hacky solution: Global variables
GLOBAL_RESEARCH_RESULTS = []

def researcher():
    global GLOBAL_RESEARCH_RESULTS
    GLOBAL_RESEARCH_RESULTS = search_papers()  # Yikes!

def coder():
    papers = GLOBAL_RESEARCH_RESULTS  # Thread-unsafe, not testable
```

**With proper state management:**
```python
# Clean: State flows through workflow
state = {'topic': 'RAG'}
state = researcher_node(state)  # {'topic': 'RAG', 'papers': [...]}
state = coder_node(state)       # {'topic': 'RAG', 'papers': [...], 'code': '...'}
```

### The Solution: Typed State with Reducers

LangGraph uses **TypedDict** for state schema and **reducers** for merge logic.

```python
from typing_extensions import TypedDict, Annotated
import operator

class MyState(TypedDict):
    # Simple field (last write wins)
    topic: str

    # List field (concatenates)
    messages: Annotated[list, operator.add]

    # Dict field (merges)
    metadata: Annotated[dict, lambda x, y: {**x, **y}]
```

---

## ðŸ“Š Our State Schema

### Complete Schema

```python
# src/graph/state.py

from typing import TypedDict, Annotated, List, Dict, Any, Optional
from operator import add

class AgentState(TypedDict):
    """
    Central state schema for the hybrid agentic system.

    State flows through all agents in the workflow. Each agent:
    1. Reads fields it needs
    2. Performs work
    3. Returns updates (merged into state)
    """

    # ===== User Input (immutable) =====
    topic: str
    """The research topic (e.g., 'RAG systems')"""

    depth: str
    """Research depth: 'basic' | 'comprehensive'"""

    report_mode: str
    """Report type: 'staff_ml_engineer' | 'research_innovation'"""

    # ===== Planning Phase =====
    plan: Optional[Dict[str, Any]]
    """Planner's execution plan with subtasks and dependencies"""

    subtasks: Optional[List[str]]
    """List of subtasks extracted from plan"""

    # ===== Research Phase =====
    research_papers: Annotated[List[Dict], add]
    """Papers from Researcher (concatenates across iterations)"""

    key_findings: Optional[List[str]]
    """Key insights extracted from papers"""

    cross_domain_insights: Optional[List[Dict]]
    """Cross-domain connections (Research Innovation mode)"""

    # ===== Code Generation Phase =====
    generated_code: Optional[Dict[str, str]]
    """Code examples: {'example_name': 'code_string'}"""

    executable_code: Optional[Dict[str, str]]
    """Validated code that passed tests"""

    test_results: Optional[Dict[str, Any]]
    """Test execution results from Tester"""

    validation_errors: Annotated[List[str], add]
    """Code validation errors (concatenates)"""

    # ===== Quality Control Phase =====
    quality_scores: Optional[Dict[str, float]]
    """Critic's evaluation: {'accuracy': 8.5, 'completeness': 7.0, ...}"""

    feedback: Optional[str]
    """Critic's improvement suggestions"""

    # ===== Output Phase =====
    final_report: Optional[str]
    """Final markdown report from Synthesizer"""

    innovation_report: Optional[str]
    """Innovation report (Research Innovation mode)"""

    implementation_report: Optional[str]
    """Implementation report (Research Innovation mode)"""

    # ===== Workflow Control =====
    iteration_count: int
    """Current iteration number (for reflection loops)"""

    max_iterations: int
    """Maximum iterations before forced stop"""

    current_phase: Optional[str]
    """Current workflow phase (for progress tracking)"""

    # ===== Communication =====
    messages: Annotated[List[Dict], add]
    """LLM message history: [{'role': 'user', 'content': '...'}, ...]"""

    # ===== Metadata =====
    metadata: Optional[Dict[str, Any]]
    """Additional metadata (timestamps, token usage, etc.)"""
```

### Field Categories

**1. Input Fields**
- Set once at workflow start
- Never modified
- Example: `topic`, `depth`, `report_mode`

**2. Work Products**
- Generated by agents
- Can be updated in reflection loops
- Example: `research_papers`, `generated_code`

**3. Control Flow**
- Determine routing decisions
- Track workflow progress
- Example: `iteration_count`, `quality_scores`

**4. Communication**
- Enable agent-to-agent messaging
- Provide context for LLMs
- Example: `messages`, `feedback`

**5. Metadata**
- Auxiliary information
- Not used for routing
- Example: `metadata` (timestamps, costs)

---

## ðŸ”§ Reducers: How State Merges

### What is a Reducer?

A **reducer** is a function that specifies how to merge new values with existing values.

```python
Annotated[Type, reducer_function]
```

**Default behavior (no reducer):**
```python
field: str
# state['field'] = new_value  # OVERWRITES
```

**With reducer:**
```python
field: Annotated[str, custom_merge_func]
# state['field'] = custom_merge_func(old_value, new_value)
```

### Built-in Reducers

#### 1. `operator.add` (Concatenate/Add)

```python
import operator

# For lists (concatenate)
messages: Annotated[List[Dict], operator.add]

# Usage:
state = {'messages': [msg1, msg2]}
update = {'messages': [msg3]}
# Result: {'messages': [msg1, msg2, msg3]}

# For numbers (add)
count: Annotated[int, operator.add]

# Usage:
state = {'count': 5}
update = {'count': 3}
# Result: {'count': 8}
```

**When to use:**
- Lists that should accumulate (messages, papers, errors)
- Counters (iteration count, token usage)

**When NOT to use:**
- Lists that should replace (e.g., current subtask list)
- Numbers that represent values, not counts (e.g., quality score)

#### 2. Lambda Reducers (Custom)

```python
# Last write wins (same as default)
field: Annotated[str, lambda old, new: new]

# Keep highest value
score: Annotated[float, lambda old, new: max(old, new)]

# Merge dicts
metadata: Annotated[dict, lambda old, new: {**old, **new}]

# Merge lists without duplicates
items: Annotated[list, lambda old, new: list(set(old + new))]

# Conditional merge (only update if new is better)
def merge_if_better(old, new):
    if new['quality'] > old['quality']:
        return new
    return old

best_result: Annotated[Dict, merge_if_better]
```

### Our Reducer Strategy

**Research papers (accumulate across iterations):**
```python
research_papers: Annotated[List[Dict], operator.add]

# Iteration 1: Researcher finds 5 papers
state['research_papers'] = [paper1, paper2, paper3, paper4, paper5]

# Iteration 2: Researcher finds 3 more (based on feedback)
update = {'research_papers': [paper6, paper7, paper8]}

# Final state: All 8 papers
state['research_papers'] = [paper1, ..., paper8]
```

**Messages (full conversation history):**
```python
messages: Annotated[List[Dict], operator.add]

# Agent 1
update = {
    'messages': [{
        'role': 'assistant',
        'content': 'I found 10 papers',
        'name': 'researcher'
    }]
}

# Agent 2
update = {
    'messages': [{
        'role': 'assistant',
        'content': 'I generated code',
        'name': 'coder'
    }]
}

# Final state: Both messages
state['messages'] = [
    {'role': 'assistant', 'content': 'I found 10 papers', ...},
    {'role': 'assistant', 'content': 'I generated code', ...}
]
```

**Validation errors (accumulate):**
```python
validation_errors: Annotated[List[str], operator.add]

# Tester iteration 1
update = {'validation_errors': ['SyntaxError on line 10']}

# Tester iteration 2 (after fix)
update = {'validation_errors': ['ImportError: missing pandas']}

# Final state: All errors encountered
state['validation_errors'] = [
    'SyntaxError on line 10',
    'ImportError: missing pandas'
]
```

**Quality scores (replace, not accumulate):**
```python
quality_scores: Optional[Dict[str, float]]  # No reducer!

# Critic iteration 1
update = {'quality_scores': {'accuracy': 6.0, 'completeness': 7.0}}
state['quality_scores'] = {'accuracy': 6.0, 'completeness': 7.0}

# Critic iteration 2 (after revision)
update = {'quality_scores': {'accuracy': 8.0, 'completeness': 8.5}}
state['quality_scores'] = {'accuracy': 8.0, 'completeness': 8.5}  # REPLACED

# We want the latest scores, not accumulated scores!
```

---

## ðŸŽ¨ State Design Patterns

### Pattern 1: Immutable Input

**Problem:** Agents might accidentally modify input.

**Solution:** Never update input fields.

```python
# Good
def agent(state: AgentState) -> Dict:
    topic = state['topic']  # Read only
    # Work with topic...
    return {'result': output}  # Don't return {'topic': modified_topic}

# Bad
def agent(state: AgentState) -> Dict:
    return {'topic': state['topic'].upper()}  # DON'T modify input!
```

### Pattern 2: Incremental Updates

**Problem:** Large state updates are inefficient.

**Solution:** Return only changed fields.

```python
# Good
def agent(state: AgentState) -> Dict:
    code = generate_code()
    return {'generated_code': code}  # Only what changed

# Bad
def agent(state: AgentState) -> Dict:
    code = generate_code()
    return {
        'topic': state['topic'],           # Unnecessary
        'depth': state['depth'],           # Unnecessary
        'research_papers': state['research_papers'],  # Unnecessary
        'generated_code': code             # Only this is needed!
    }
```

### Pattern 3: Defensive Reads

**Problem:** Field might not exist in state.

**Solution:** Use `.get()` with defaults.

```python
# Good
def agent(state: AgentState) -> Dict:
    papers = state.get('research_papers', [])
    if not papers:
        logger.warning("No papers found, using defaults")
        papers = get_default_papers()
    # Continue...

# Bad
def agent(state: AgentState) -> Dict:
    papers = state['research_papers']  # KeyError if not present!
```

### Pattern 4: Iteration Tracking

**Problem:** Need to know which iteration we're on.

**Solution:** Increment counter in each loop.

```python
# In reflection loop
def revision_node(state: AgentState) -> Dict:
    current = state.get('iteration_count', 0)

    # Do work...

    return {
        'iteration_count': current + 1,  # Increment
        'result': output
    }

# In routing logic
def should_continue(state: AgentState) -> str:
    if state['iteration_count'] >= state['max_iterations']:
        return "stop"
    return "continue"
```

### Pattern 5: Phase Tracking

**Problem:** Need to track where we are in workflow.

**Solution:** Update phase field at each stage.

```python
def planner_node(state: AgentState) -> Dict:
    # Work...
    return {
        'current_phase': 'planning',
        'plan': plan_output
    }

def researcher_node(state: AgentState) -> Dict:
    # Work...
    return {
        'current_phase': 'research',
        'research_papers': papers
    }

# In UI, show current phase
async for event in workflow.stream(state):
    phase = event['state'].get('current_phase', 'unknown')
    print(f"Currently in: {phase}")
```

---

## ðŸ§ª Testing State Management

### Test 1: Reducer Behavior

```python
def test_message_accumulation():
    """Test that messages accumulate, not overwrite."""

    from src.graph.state import AgentState
    from operator import add

    # Simulate state updates
    state = AgentState(messages=[])

    # Update 1
    update1 = {'messages': [{'role': 'user', 'content': 'Hello'}]}
    # Manually merge (LangGraph does this automatically)
    state['messages'] = add(state['messages'], update1['messages'])

    # Update 2
    update2 = {'messages': [{'role': 'assistant', 'content': 'Hi'}]}
    state['messages'] = add(state['messages'], update2['messages'])

    # Assert: Both messages present
    assert len(state['messages']) == 2
    assert state['messages'][0]['content'] == 'Hello'
    assert state['messages'][1]['content'] == 'Hi'
```

### Test 2: State Immutability

```python
def test_state_not_mutated():
    """Test that nodes don't mutate original state."""

    from src.graph.nodes import researcher_node

    original_state = {
        'topic': 'RAG',
        'messages': [{'role': 'user', 'content': 'Test'}]
    }

    # Copy to detect mutations
    import copy
    state_before = copy.deepcopy(original_state)

    # Execute node
    result = researcher_node(original_state)

    # Assert: Original state unchanged
    assert original_state == state_before
    # Result is separate dict
    assert 'research_papers' in result
```

### Test 3: Default Values

```python
def test_missing_fields_have_defaults():
    """Test that agents handle missing fields gracefully."""

    from src.graph.nodes import coder_node

    # State missing research_papers
    state = {'topic': 'RAG'}

    # Should not crash
    result = coder_node(state)

    # Should handle gracefully (check logs for warnings)
    assert 'generated_code' in result or 'error' in result
```

---

## ðŸ” Common State Mistakes

### Mistake 1: Mutating State

```python
# WRONG
def bad_node(state: AgentState) -> Dict:
    state['messages'].append(new_msg)  # Mutates state!
    return state

# RIGHT
def good_node(state: AgentState) -> Dict:
    return {'messages': [new_msg]}  # Returns update, doesn't mutate
```

### Mistake 2: Not Using Reducers for Lists

```python
# WRONG
messages: List[Dict]  # No reducer!

# Agent returns: {'messages': [new_msg]}
# State becomes: {'messages': [new_msg]}  # Previous messages lost!

# RIGHT
messages: Annotated[List[Dict], operator.add]

# Agent returns: {'messages': [new_msg]}
# State becomes: {'messages': [old_msg1, old_msg2, new_msg]}  # Accumulated!
```

### Mistake 3: Returning Entire State

```python
# WRONG (inefficient)
def bad_node(state: AgentState) -> Dict:
    code = generate_code()
    return {**state, 'generated_code': code}  # Returns everything!

# RIGHT (efficient)
def good_node(state: AgentState) -> Dict:
    code = generate_code()
    return {'generated_code': code}  # Returns only changes
```

### Mistake 4: KeyError on Missing Fields

```python
# WRONG
def bad_node(state: AgentState) -> Dict:
    papers = state['research_papers']  # Crashes if missing!

# RIGHT
def good_node(state: AgentState) -> Dict:
    papers = state.get('research_papers', [])
    if not papers:
        # Handle missing data
        return {'error': 'No papers found'}
```

### Mistake 5: Wrong Reducer for Use Case

```python
# WRONG
iteration_count: Annotated[int, lambda x, y: max(x, y)]
# Problem: Won't increment properly!

# Example:
state['iteration_count'] = 1
update = {'iteration_count': 2}
# Result: max(1, 2) = 2 âœ“

state['iteration_count'] = 2
update = {'iteration_count': 2}
# Result: max(2, 2) = 2 âœ— (should be 3!)

# RIGHT
iteration_count: Annotated[int, operator.add]
# OR just use replacement (default):
iteration_count: int

# And increment manually:
return {'iteration_count': state['iteration_count'] + 1}
```

---

## ðŸ’¾ State Persistence

### Checkpointing

LangGraph supports **checkpointing** to persist state across runs.

```python
from langgraph.checkpoint import MemorySaver

# Create workflow with checkpointer
checkpointer = MemorySaver()
workflow = create_workflow().compile(checkpointer=checkpointer)

# Execute with thread ID
config = {"configurable": {"thread_id": "user_123"}}
result = workflow.invoke(state, config)

# Resume later
config = {"configurable": {"thread_id": "user_123"}}
continued = workflow.invoke(new_input, config)
# State from previous run is loaded automatically!
```

**Use cases:**
- Long-running workflows (pause/resume)
- Human-in-the-loop (wait for approval)
- Error recovery (restart from checkpoint)

**We don't use checkpointing currently because:**
- Workflows complete in minutes (no pause needed)
- No human-in-the-loop steps
- Simpler architecture without persistence

**When to add checkpointing:**
- Workflows take hours/days
- Need user approval mid-workflow
- Want to recover from crashes

---

## ðŸ“ State Size Management

### Problem: State Grows Unbounded

```python
# After 3 iterations with 20 papers each
state['research_papers'] = [paper1, ..., paper60]  # 60 papers!

# Messages accumulate
state['messages'] = [msg1, ..., msg50]  # 50 messages!

# Eventually hits LangGraph limits or LLM context limits
```

### Solution 1: Keep Only Recent

```python
def agent(state: AgentState) -> Dict:
    messages = state.get('messages', [])

    # Keep only last 10 messages
    recent_messages = messages[-10:]

    # Use recent_messages for LLM context
    response = llm.generate(messages=recent_messages)

    return {'messages': [{'role': 'assistant', 'content': response}]}
```

### Solution 2: Use Memory Instead of State

```python
# DON'T store full papers in state
# DO store references
def researcher_node(state: AgentState) -> Dict:
    papers = search_papers(state['topic'])

    # Store full papers in FAISS
    memory = get_memory_manager()
    for paper in papers:
        memory.store(
            content=f"{paper['title']}: {paper['abstract']}",
            metadata={'paper_id': paper['id']}
        )

    # Only store IDs in state
    return {
        'research_papers': [{'id': p['id'], 'title': p['title']} for p in papers]
    }
```

### Solution 3: Summarization

```python
def synthesizer_node(state: AgentState) -> Dict:
    papers = state['research_papers']

    # Instead of passing all papers to LLM
    # Summarize first
    summaries = [summarize_paper(p) for p in papers]

    report = llm.generate(f"Create report from: {summaries}")

    return {'final_report': report}
```

---

## ðŸŽ¯ Best Practices

### 1. Keep State Flat

```python
# Bad (nested)
state = {
    'research': {
        'papers': [...],
        'findings': {
            'key_points': [...],
            'methodologies': [...]
        }
    }
}

# Good (flat)
state = {
    'research_papers': [...],
    'research_findings_key_points': [...],
    'research_findings_methodologies': [...]
}
```

### 2. Use Semantic Names

```python
# Bad
state = {
    'data': [...],      # What data?
    'result': '...',    # Which result?
    'flag': True        # What flag?
}

# Good
state = {
    'research_papers': [...],
    'final_report': '...',
    'needs_revision': True
}
```

### 3. Document State Fields

```python
class AgentState(TypedDict):
    topic: str
    """The research topic (e.g., 'RAG systems')"""  # âœ“ Documented

    research_papers: Annotated[List[Dict], add]
    """Papers from Researcher (concatenates across iterations)"""  # âœ“ Clear
```

### 4. Validate State Shape

```python
def agent(state: AgentState) -> Dict:
    # Validate required fields
    required = ['topic', 'depth', 'report_mode']
    for field in required:
        if field not in state:
            raise ValueError(f"Missing required field: {field}")

    # Validate types
    if not isinstance(state.get('iteration_count', 0), int):
        raise TypeError("iteration_count must be int")

    # Proceed with work...
```

### 5. Log State Transitions

```python
def agent(state: AgentState) -> Dict:
    logger.info(f"[Agent] Input state keys: {state.keys()}")

    # Do work
    result = do_work()

    update = {'result': result}
    logger.info(f"[Agent] Updating state with: {update.keys()}")

    return update
```

---

## ðŸš€ Key Takeaways

1. **State is the communication layer**
   - All agents read and write to shared state
   - No global variables needed

2. **Reducers control merge behavior**
   - `operator.add` for lists/counters
   - Default (last-write-wins) for values
   - Custom lambdas for complex logic

3. **Keep state minimal**
   - Only what's needed for routing and output
   - Use memory for large data
   - Summarize when possible

4. **Defensive programming**
   - Use `.get()` with defaults
   - Validate required fields
   - Handle missing data gracefully

5. **Return only changes**
   - Don't return entire state
   - Only return updated fields
   - LangGraph merges automatically

---

## ðŸš€ Next Steps

**Next:** `06_AGENT_IMPLEMENTATION_PATTERNS.md` (already created) â†’ How to implement production-grade agents

**Exercise:** Modify the state schema to add a new field `workflow_start_time` that tracks when the workflow started. Update the planner node to set this field.

**Advanced Exercise:** Implement a custom reducer for `quality_scores` that keeps a history of scores across iterations:

```python
def quality_history_reducer(old: List[Dict], new: Dict) -> List[Dict]:
    """Keep history of all quality scores."""
    return old + [new]

quality_score_history: Annotated[List[Dict[str, float]], quality_history_reducer]
```

Then plot quality improvement over iterations.

---

**Key Insight:** State management is 50% of building a multi-agent system. Get it right, and everything else falls into place. Get it wrong, and you'll fight bugs forever. Invest time in designing your state schema upfront.
